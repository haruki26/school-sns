import { fakerJA as faker } from '@faker-js/faker'
import { PrismaClient } from '../../generated/prisma/index.js'

const prisma = new PrismaClient()

async function main() {
  // 1. クリーンアップ（削除の順番に注意：子から親へ）
  await prisma.userRelationships.deleteMany()
  await prisma.comments.deleteMany()
  await prisma.tagScraps.deleteMany()
  await prisma.scraps.deleteMany()
  await prisma.assets.deleteMany()
  await prisma.tagArtifacts.deleteMany()
  await prisma.artifacts.deleteMany()
  await prisma.tags.deleteMany()
  await prisma.users.deleteMany()

  // 2. Tags の作成（あらかじめ共通のタグを作っておく）
  const tagNames = ['React', 'Rust', 'TypeScript', 'Prisma', 'Hono', 'Next.js']
  const tags = await Promise.all(
    tagNames.map((name) => prisma.tags.create({ data: { name } })),
  )

  // 3. Users の作成 (10人)
  const users = []
  for (let i = 0; i < 10; i++) {
    const user = await prisma.users.create({
      data: {
        email: faker.internet.email(),
        userName: faker.person.fullName(),
      },
    })
    // https://www.dicebear.com を使ってアバター画像URLを生成
    const avatarUrl = `https://api.dicebear.com/9.x/thumbs/svg?seed=${user.id}`
    const updatedUser = await prisma.users.update({
      where: { id: user.id },
      data: { avatarUrl },
    })
    users.push(updatedUser)
  }

  // 4. UserRelationships (フォロー関係の作成)
  for (const user of users) {
    // 自分以外のユーザーからランダムに2〜3人選んでフォローする
    const others = users.filter((u) => u.id !== user.id)
    const followTargets = others.sort(() => 0.5 - Math.random()).slice(0, 2)

    for (const target of followTargets) {
      await prisma.userRelationships.create({
        data: {
          followerId: user.id,
          followeeId: target.id,
        },
      })
    }
  }

  // 5. Artifacts
  const artifactSeeds = getJapaneseArtifactSeeds()
  let artifactIndex = 0

  for (const user of users) {
    // ランダムに2つの異なるタグを選択
    const selectedTags = [...tags].sort(() => 0.5 - Math.random()).slice(0, 2)

    const seed = artifactSeeds[artifactIndex % artifactSeeds.length]
    artifactIndex++

    const artifact = await prisma.artifacts.create({
      data: {
        title: seed.title,
        body: seed.body,
        userId: user.id,
        publishedAt: new Date(),
        tagArtifacts: {
          create: selectedTags.map((tag) => ({
            tag: {
              connect: { id: tag.id },
            },
          })),
        },
      },
    })
    // summaryByAI の更新
    await prisma.artifacts.update({
      where: { id: artifact.id },
      data: { summaryByAI: seed.summaryByAI },
    })
  }

  // 6. Scraps (再帰構造 + Tag紐付け)
  const scrapSeeds = getJapaneseScrapSeeds()
  let scrapSeedIndex = 0

  for (const user of users) {
    const seed = scrapSeeds[scrapSeedIndex % scrapSeeds.length]
    scrapSeedIndex++

    const selectedTags = [...tags].sort(() => 0.5 - Math.random()).slice(0, 2)

    // 親スクラップの作成
    const parentScrap = await prisma.scraps.create({
      data: {
        body: seed.parent.body,
        userId: user.id,
        tagScraps: {
          create: selectedTags.map((tag) => ({
            tag: {
              connect: { id: tag.id },
            },
          })),
        },
      },
    })

    // 子スクラップ（返信）の作成
    // 返信は 0~3 件ランダムに作成
    const maxReplies = Math.min(seed.replies.length, 3)
    const numReplies = Math.floor(Math.random() * (maxReplies + 1))

    const pickedReplies = [...seed.replies]
      .sort(() => 0.5 - Math.random())
      .slice(0, numReplies)

    for (const reply of pickedReplies) {
      const replyUser = users[Math.floor(Math.random() * users.length)]
      await prisma.scraps.create({
        data: {
          body: reply.body,
          userId: replyUser.id,
          parentId: parentScrap.id,
          tagScraps: {
            create: selectedTags.map((tag) => ({
              tag: {
                connect: { id: tag.id },
              },
            })),
          },
        },
      })
    }
  }

  // 7. Comments (再帰構造: Artifactに対するコメント -> 返信)
  const allArtifacts = await prisma.artifacts.findMany()
  for (const artifact of allArtifacts) {
    // 最初のコメント
    const rootComment = await prisma.comments.create({
      data: {
        body: faker.lorem.sentence(),
        userId: users[Math.floor(Math.random() * users.length)].id,
        artifactId: artifact.id,
      },
    })

    // コメントへの返信（1階層）
    await prisma.comments.create({
      data: {
        body: `Replying to comment: ${faker.lorem.sentence()}`,
        userId: users[Math.floor(Math.random() * users.length)].id,
        artifactId: artifact.id,
        parentId: rootComment.id, // 自己参照ID
      },
    })
  }

  console.log('Seed data created successfully!')
}
main()
  .catch((e: unknown) => {
    // e が Error オブジェクトかどうかをチェックして、適切に表示
    if (e instanceof Error) {
      console.error(e.message)
    } else {
      console.error('An unexpected error occurred:', e)
    }
    throw e
  })
  .finally(async () => {
    // 成功・失敗に関わらず接続を切断
    await prisma.$disconnect()
  })

// ------------------------------
// 固定 seed（Artifacts / Scraps）
// ------------------------------
export interface SeedText {
  title: string
  body: string
}
export interface ArtifactSeed extends SeedText {
  summaryByAI: string
}
export interface ScrapSeed {
  parent: SeedText
  replies: SeedText[]
}

export function getJapaneseArtifactSeeds(): ArtifactSeed[] {
  return [
    // ---- IT（7）----
    {
      title: 'DayClip：イベント準備をまとめるWebアプリ',
      body: [
        '文化祭の準備で「やること・資料・画像」が散らばって爆発したので、まとめるアプリを作りました。',
        '',
        '### 主な機能',
        '- タスク（締切 / 優先度 / 担当）',
        '- 画像貼り付けメモ（会場図、購入リストの写真とか）',
        '- タグ検索',
        '',
        '地味に効いたのが、**入力直後に即反映**されるところです。遅延があると“保存できた？”って不安になります。',
        '',
        '```txt',
        '次にやりたい：スマホの片手操作を意識したUI / 共有リンク',
        '```',
      ].join('\n'),
      summaryByAI: [
        '文化祭の準備を効率化するためのWebアプリ「DayClip」を開発。タスク管理、画像メモ、タグ検索などの機能を搭載し、即時反映されるUIでユーザー体験を向上。',
      ].join(' '),
    },
    {
      title: 'スクロールで見せるポートフォリオを作って反省したこと',
      body: [
        '「普通に並べるだけ」だと印象が薄い気がして、スクロールに合わせて演出が変わるポートフォリオにしました.',
        '',
        'やってみて分かったのは、演出を足すほど **重さと読みやすさ** が敵になること。',
        '',
        '途中から方針を変えて、',
        '- 最初の1ブロックだけ演出強め',
        '- 作品一覧は軽さ優先',
        '- 画像は段階読み込み',
        '',
        'に寄せたら「見れる」感じになりました。',
      ].join('\n'),
      summaryByAI: [
        'スクロールに連動した演出を取り入れたポートフォリオを作成。演出の追加がパフォーマンスと可読性に与える影響を考慮し、最初のセクションに重点を置き、作品一覧では軽量化を図ることでユーザー体験を最適化。',
      ].join(' '),
    },
    {
      title: 'QRで出欠を集計するミニシステム（試作）',
      body: [
        '授業で紙の出席が手間だったので、QRで集計する仕組みを試作しました。',
        '',
        '### 流れ',
        '- 先生：QRを表示',
        '- 学生：読み取って送信',
        '- 管理：一覧＆CSV出力',
        '',
        '作ってて一番気をつけたのは「連打」と「通信失敗」です。',
        '送信ボタンは押したらロック、失敗したら“もう一回だけ”が分かる表示にしました。',
        '',
        'セキュリティはまだ課題で、次は“偽装”対策を考えたいです。',
      ].join('\n'),
      summaryByAI: [
        '授業での出席管理を効率化するために、QRコードを利用した出欠集計システムを試作。連打や通信失敗への対策を実装し、ユーザーの操作ミスを減らす工夫を行った。',
      ].join(' '),
    },
    {
      title: '音楽の感想を共有するアプリのプロトタイプ',
      body: [
        '聴いた曲の感想をメモるのが好きなので、共有できる形をプロトで作りました.',
        '',
        '## 画面',
        '- タイムライン（投稿一覧）',
        '- 曲検索 → 投稿',
        '- タグ（ジャンル / 気分）',
        '',
        '検索は同じ曲を何回も叩きがちだったので、キャッシュを入れました。',
        '「速くなった」より **落ち着く** 感覚が大きいです。',
      ].join('\n'),
      summaryByAI: [
        '聴いた曲の感想をメモるのが好きなので、共有できる形をプロトで作りました.',
      ].join(' '),
    },
    {
      title: '作品展の展示マップ（スマホ向けWeb）',
      body: [
        '作品展で迷子が発生しがちだったので、スマホで見れる展示マップを作りました。',
        '',
        '- フロアを選ぶ',
        '- カテゴリで絞る',
        '- タップで作者コメントを見る',
        '',
        '小さい工夫ですが、表示がごちゃつかないように**情報を折りたたむ**前提にしてます。',
        '最初から全部見せると、見た瞬間に読む気が消えました。',
      ].join('\n'),
      summaryByAI: [
        '作品展で迷子が発生しがちだったので、スマホで見れる展示マップを作成。フロア選択、カテゴリ絞り込み、タップで作者コメント表示などの機能を搭載し、情報の折りたたみで見やすさを工夫した。',
      ].join(' '),
    },
    {
      title: '画像を一括でリネームするCLIツール',
      body: [
        '写真フォルダがカオスになりがちなので、まとめてリネームするCLIを作りました。',
        '',
        '### ルール',
        '`YYYYMMDD_連番_元名` に統一',
        '',
        '### こだわり',
        '- `dry-run` を必須にして、いきなり破壊しない',
        '- 失敗したファイルだけログに残す',
        '',
        '便利より **壊さない** の方が価値が高いと学びました。',
      ].join('\n'),
      summaryByAI: [
        '写真フォルダがカオスになりがちなので、まとめてリネームするCLIを作成。破壊的な操作を避けるためにdry-runを必須とし、失敗したファイルのみログに残す工夫を行った。',
      ].join(' '),
    },
    {
      title: '課題の締切と提出リンクをまとめるページ',
      body: [
        '締切が重なると普通に忘れるので、一覧ページを作りました。',
        '',
        '- 今日が締切のものを上に出す',
        '- 遅れてるものは“色だけじゃなく”ラベルも付ける',
        '- 提出リンクを一緒に置く（これが地味に便利）',
        '',
        '「カレンダーでよくない？」とも思ったけど、提出リンクが迷子にならないのが助かってます。',
      ].join('\n'),
      summaryByAI: [
        '締切が重なると忘れがちな課題の管理を効率化するため、締切順に表示し遅延をラベルで明示、提出リンクも一緒に配置した一覧ページを作成。カレンダーよりも提出リンクの管理がしやすい点が利点。',
      ].join(' '),
    },

    // ---- CG / イラスト（7）----
    {
      title: 'オリキャラ立ち絵：表情差分を作ってやっと“キャラっぽく”なった',
      body: [
        '立ち絵を完成させたあと、表情差分を追加しました。',
        '',
        '最初は「目と口だけ変えればOK」だと思ってたんですが、やるほど不自然になりました。',
        '眉と頬の形を少し動かすだけで、急に自然になります。',
        '',
        '- 喜怒哀楽',
        '- 困り / 焦り / 照れ',
        '- 無表情（逆に大事）',
        '',
        '次は塗りを変えて、厚塗り寄りにも挑戦したいです。',
      ].join('\n'),
      summaryByAI: [
        '立ち絵を完成させたあと、表情差分を追加。目と口だけでなく眉と頬の形も調整することで自然な表情を実現。喜怒哀楽や困り、焦り、照れ、無表情など多様な表情を作成し、次は塗りのスタイルにも挑戦予定。',
      ].join(' '),
    },
    {
      title: '背景イラスト：雨上がりの駅前（反射がむずい）',
      body: [
        '雨上がりの反射を描きたくて背景を作りました。',
        '',
        '反射って“鏡”みたいに全部描くほど汚くなって、',
        '**情報を間引いた別世界**くらいにする方がまとまりました。',
        '',
        '### 自分ルール',
        '- 反射は色数少なめ',
        '- 人影は形で置く（描き込みすぎない）',
        '- 看板の光は少し滲ませる',
      ].join('\n'),
      summaryByAI: [
        '雨上がりの反射を描く際に、鏡のように全てを描くと汚くなるため、情報を間引いた別世界として表現。反射の色数を抑え、人影は形で表現し、看板の光は少し滲ませるなどの自分ルールを設定してまとまりを持たせた。',
      ].join(' '),
    },
    {
      title: '低ポリ背景：部屋を作って“配置”の大事さを知った',
      body: [
        'ゲーム背景を想定して、低ポリで部屋を作りました。',
        '',
        '作ってて思ったのは、ディテールより **配置** が説得力を作るということ。',
        '小物を増やす前に、まず“生活感の流れ”を置いた方がそれっぽいです。',
        '',
        '作ったもの：机 / 椅子 / PC / 本棚 / 小物',
      ].join('\n'),
      summaryByAI: [
        'ゲーム背景を想定して低ポリで部屋を作成。ディテールよりも配置の重要性を実感し、生活感の流れを意識して小物を配置することで説得力を持たせた。',
      ].join(' '),
    },
    {
      title: 'モデリング練習：古いラジオ（角処理が地獄）',
      body: [
        'ハードサーフェスの練習で古いラジオを作りました。',
        '',
        '角を丸めすぎるとおもちゃっぽい、立てすぎるとカクカクで嘘っぽい。',
        '最終的に、**大きい角だけ丸める**のが一番バランス良かったです。',
        '',
        '素材感（プラ/金属）で“丸さ”を変えると説得力が出ました。',
      ].join('\n'),
      summaryByAI: [
        'ハードサーフェスの練習で古いラジオを作成。角の丸め具合を調整し、素材感に応じて丸さを変えることで説得力を持たせた。',
      ].join(' '),
    },
    {
      title: '2秒ループ映像を作った（つなぎ目を消すコツ）',
      body: [
        '短いループ映像を作りました。短いほどつなぎ目がバレます。',
        '',
        '位置を合わせるより、',
        '- 動きの方向',
        '- 明るさの変化',
        '- 視線誘導',
        '',
        'を揃える方が自然に見えました。',
      ].join('\n'),
      summaryByAI: [
        '短いループ映像を作成。つなぎ目を自然に見せるために、位置合わせよりも動きの方向、明るさの変化、視線誘導を揃える工夫を行った。',
      ].join(' '),
    },
    {
      title: '石畳テクスチャ：ノイズより“欠けの理由”が効く',
      body: [
        '質感作りの練習で石畳テクスチャを作りました。',
        '',
        '最初はノイズを足しまくってたけど、全然リアルにならない。',
        'ひび割れや欠けに **方向と理由** を入れると急にそれっぽくなりました。',
        '',
        '次は木材で同じことをやります。',
      ].join('\n'),
      summaryByAI: [
        '質感作りの練習で石畳テクスチャを作成。ノイズを足すだけではリアルにならず、ひび割れや欠けに方向と理由を持たせることでリアリティを向上。次は木材で同様の手法を試す予定。',
      ].join(' '),
    },
    {
      title: '同人ゲーム用のUIパーツを先に整えた（ボタン/アイコン）',
      body: [
        'UIが弱いと全体が安っぽく見える気がして、先にUIパーツを作りました。',
        '',
        '- ボタン（通常/ホバー/押下）',
        '- タブ、ダイアログ',
        '- アイコン20個',
        '',
        'アイコンは細かく描くほど読めないので、**シルエット重視**にしました。',
      ].join('\n'),
      summaryByAI: [
        '同人ゲームのUIパーツ（ボタン、タブ、ダイアログ、アイコン）を先に作成。アイコンは細かく描くよりもシルエット重視でデザインし、全体の品質向上を図った。',
      ].join(' '),
    },

    // ---- ゲーム制作（6）----
    {
      title: '2Dアクション：移動の手触りだけ先に作った',
      body: [
        'ステージより先に「触って気持ちいい移動」を作りました。',
        '',
        '- 加速/減速（急に止まらない）',
        '- ジャンプの高さ調整（短押し/長押し）',
        '- 着地の硬さ（少しだけ揺らす）',
        '',
        '物理が正しいかより、**入力に対して返事があるか**が大事だと感じました。',
      ].join('\n'),
      summaryByAI: [
        'ステージより先に「触って気持ちいい移動」を作成。加速/減速、ジャンプの高さ調整、着地の硬さなど、物理的な正確さよりも入力に対するフィードバックを重視した。',
      ].join(' '),
    },
    {
      title: '1画面パズル：20ステージ作って友達にテストしてもらった',
      body: [
        '作って満足しないように、友達に触ってもらって直しました。',
        '',
        '言われたこと：',
        '- ルール説明が長い',
        '- 失敗しても原因が分からない',
        '- クリア時が地味',
        '',
        '直したこと：',
        '- ルールは最初の2ステージで体験させる',
        '- 失敗時に“何がダメか”を短く出す',
        '- SE追加',
        '',
        'テストは地味だけど、ゲームが一気に良くなりました。',
      ].join('\n'),
      summaryByAI: [
        'ゲーム制作において、友達にテストプレイしてもらいフィードバックを基に改善。ルール説明の簡素化、失敗時の原因表示、クリア時の効果音追加など、ユーザー体験を向上させた。',
      ].join(' '),
    },
    {
      title: 'ホラー：暗闇探索の“音”だけ先に作ると強い',
      body: [
        'ホラーは演出が命なので、グラより先に音を作りました。',
        '',
        '- 足音（床で変える）',
        '- 遠くの音（方向が分かる程度）',
        '- 近づく気配（心拍っぽい）',
        '',
        '音で情報を出しすぎると楽になりすぎるので、今は“最低限のヒント”にしています。',
      ].join('\n'),
      summaryByAI: [
        'ホラーゲーム制作において、グラフィックより先に音響を重視。足音、遠くの音、近づく気配など、最低限のヒントを提供することで緊張感を維持。',
      ].join(' '),
    },
    {
      title: '会話ADV：ログ/選択肢/オートを実装した（地味に重要）',
      body: [
        'ADVの基礎UIを作りました。地味だけど、ここが弱いと遊びにくい。',
        '',
        '- ログ（巻き戻し）',
        '- 選択肢（キーボード/ゲームパッド）',
        '- オート/スキップ',
        '',
        '一番大事だと思ったのは、**今どのモードか**を分かりやすく見せることでした。',
      ].join('\n'),
      summaryByAI: [
        'アドベンチャーゲームの基礎UIを作成。ログ、選択肢、オート/スキップ機能を実装し、ユーザーが現在のモードを分かりやすく把握できるように工夫した。',
      ].join(' '),
    },
    {
      title: 'ドット絵キャラ：歩行アニメ作った（斜めが難しい）',
      body: [
        'キャラをドットで自作して歩行アニメを作りました。',
        '',
        '斜め方向が特に破綻しやすくて、情報量を減らすと安定しました。',
        '腕の振りは大げさな方が読みやすいです。',
      ].join('\n'),
      summaryByAI: [
        'ドット絵でキャラクターを自作し、歩行アニメーションを制作。特に斜め方向の表現が難しく、情報量を減らすことで安定させ、腕の振りを大げさにすることで読みやすさを向上させた。',
      ].join(' '),
    },
    {
      title: '短いチュートリアルだけ作る練習（説明なしで伝える）',
      body: [
        'レベルデザインの練習で、最初の1分だけを作りました。',
        '',
        '方針：',
        '- 説明文は使わない',
        '- 視線誘導で教える',
        '',
        '置いたギミック：',
        '- 1回だけ失敗して学べる穴',
        '- 安全な場所で試せる床ギミック',
        '',
        '説明なしでもだいたい伝わったので嬉しい。',
      ].join('\n'),
      summaryByAI: [
        'レベルデザインの練習として、最初の1分間のチュートリアルを作成。説明文を使わず視線誘導で教える方針を採用し、失敗から学べる穴や安全な場所で試せる床ギミックを配置することで、プレイヤーに自然にゲームのルールを理解させることに成功。',
      ].join(' '),
    },
  ]
}

export function getJapaneseScrapSeeds(): ScrapSeed[] {
  return [
    // ---- IT（7）----
    {
      parent: {
        title: 'APIのエラー形式、途中から揃えるのって大変？',
        body: '画面が増えるほどエラーの返し方がバラバラになってきた。後から統一するのしんどい予感がしてる。',
      },
      replies: [
        {
          title: 'エラー形式は早めに決めた方が楽',
          body: '`{ code, message }` みたいに最低限だけ固定するとフロントが助かる。人向けと機械向けを分けるのがコツ。',
        },
        {
          title: 'ログ用の情報も一緒に考えると後で救われる',
          body: 'ユーザーには短い文、ログには詳細。追跡用のIDを入れると「再現しないバグ」で詰みにくい。',
        },
        {
          title: '最初から完璧にしなくていい',
          body: 'まずは形式だけ統一して、細かいコード体系は後からでも間に合う。バラバラの方が辛い。',
        },
      ],
    },
    {
      parent: {
        title: 'seedを毎回全消しする運用って普通？',
        body: '開発中は全部消して入れ直ししてるけど、正しいのか不安になってきた。',
      },
      replies: [
        {
          title: '開発なら全消しでOK',
          body: '壊していい環境なら全消しが一番速い。怖いのは“本番っぽい環境”に同じ癖を持ち込むこと。',
        },
        {
          title: '環境で方針を分けるのが現実的',
          body: '開発は全消し、ステージングは `upsert` で固定データだけ、みたいに分けると事故りにくい。',
        },
        {
          title: 'データの依存関係だけは注意',
          body: '外部キーで消せない問題が出るので、削除順やCASCADEの方針は先に決めた方が良い。',
        },
      ],
    },
    {
      parent: {
        title: 'ポートフォリオの演出、やりすぎて重くなった',
        body: '動かすほど雰囲気は出るけど、スクロールがカクつく。どこで止めるのが正解？',
      },
      replies: [
        {
          title: '“核”だけ演出強めが強い',
          body: '全部動かすより、最初の1ブロックだけ印象づけて、あとは読みやすさ優先が安定。',
        },
        {
          title: '画像の扱いを変えるだけでかなり変わる',
          body: '画像サイズ統一＋段階読み込みで体感が改善しやすい。演出よりまず土台が効く。',
        },
        {
          title: 'スマホ実機で判断した方がいい',
          body: 'PCで軽くてもスマホだと死ぬ。実機で“引っかかる瞬間”を探すと止めどころが見える。',
        },
      ],
    },
    {
      parent: {
        title: '提出管理の色分け、色弱配慮どうする？',
        body: '締切の色分けを入れたいけど、色だけに頼るのは避けたい。',
      },
      replies: [
        {
          title: '色＋ラベル＋並び順の3点セットが強い',
          body: '色だけだと伝わらないことがある。アイコンやラベル、優先表示で意味を重ねると安全。',
        },
        {
          title: 'コントラストが大事',
          body: '薄い色は読めない。背景とのコントラストを強めて、状態の種類を増やしすぎないのが良い。',
        },
        {
          title: '“締切が近い”を色で表現しすぎない',
          body: 'グラデーションで段階表現すると余計に分かりにくい。段階は3つくらいに切った方が迷わない。',
        },
      ],
    },
    {
      parent: {
        title: '画像多めのページ、初期表示が遅い',
        body: '作品展マップみたいなページで画像が多いと遅い。段階読み込み以外に効くことある？',
      },
      replies: [
        {
          title: 'まずは画像のサイズを揃える',
          body: 'バラバラだと無駄が出る。適切なサイズに変換してサムネ→本画像の2段にすると安定。',
        },
        {
          title: '一覧は“軽い情報だけ”にする',
          body: '一覧で全部出すと重い。詳細で本画像を出す設計にすると体感がかなり変わる。',
        },
        {
          title: 'キャッシュは地味に効く',
          body: '何度も行き来する画面なら、再訪時の体感が大きい。最初の読み込みだけに目を向けすぎないのも大事。',
        },
      ],
    },
    {
      parent: {
        title: 'フロントとAPIの型共有、どこまでやる？',
        body: '共通パッケージを作ったけど、共有しすぎると依存が絡みそうで怖い。',
      },
      replies: [
        {
          title: '入出力だけ共有が無難',
          body: 'DTO/Schemaだけ共有して、内部モデルは共有しない方が壊れにくい。',
        },
        {
          title: 'DBの型まで共有すると痛い',
          body: 'DB変更がフロントに波及して、修正範囲が広がる。境界の型だけに絞ると楽。',
        },
        {
          title: 'まずは“契約”を固定する',
          body: '契約が固まるとUIが安定する。型共有は“楽するため”じゃなく“ズレないため”の道具。',
        },
      ],
    },
    {
      parent: {
        title: 'ログイン保持を長くしたいけど、怖さもある',
        body: '毎回ログインさせたくない。長いセッションってどのくらいが現実的？',
      },
      replies: [
        {
          title: '端末が限定なら現実的',
          body: '家の端末だけ、みたいな前提なら長めはアリ。その代わりログアウト導線はちゃんと用意した方がいい。',
        },
        {
          title: '“紛失時”を想像すると線引きしやすい',
          body: '端末を落とした時に困るなら短くする。困らない/失効できるなら長めでも良い。',
        },
        {
          title: '更新トークン運用は設計が要る',
          body: '長期ログインは便利だけど、更新や失効の設計が必要。最初から複雑にしすぎないのも大事。',
        },
      ],
    },

    // ---- CG / イラスト（7）----
    {
      parent: {
        title: '表情差分、何種類くらい作ると“セット感”出る？',
        body: '喜怒哀楽だけだと薄い気がする。どこまで増やすのがちょうどいい？',
      },
      replies: [
        {
          title: '困り/焦り/照れがあると強い',
          body: '日常でよく出る感情が増えると一気に使いやすい。10前後あると“作品感”が出やすい。',
        },
        {
          title: '眉と頬の動きが効く',
          body: '目口だけ変えると嘘っぽい。眉の角度と頬の形を少し動かすと自然になる。',
        },
        {
          title: '無表情も差分として大事',
          body: '無表情があると他の表情が映える。差分は“派手さ”だけじゃなく“基準”も必要。',
        },
      ],
    },
    {
      parent: {
        title: '反射を描くほど画面が散らかる',
        body: '雨上がりの反射を頑張るほど汚くなる。情報量の減らし方が分からない。',
      },
      replies: [
        {
          title: '反射は“省略した世界”にするとまとまる',
          body: '全部描くとノイズになる。色数を減らして形を大きくすると自然になりやすい。',
        },
        {
          title: 'コントラストを上げすぎない',
          body: '反射を主役にすると散らかる。主役（人物/看板/空気感）を決めて反射は補助に。',
        },
        {
          title: '人影は描き込みより形で置く',
          body: '反射の中の人物は情報量を落とす方がそれっぽい。線を足すほど嘘になることがある。',
        },
      ],
    },
    {
      parent: {
        title: '低ポリ背景、小物を増やすほど統一感が壊れる',
        body: '作るの楽しくて小物足しまくったらごちゃごちゃになった。線引きどうしてる？',
      },
      replies: [
        {
          title: '引きで見て必要なものだけ残す',
          body: '拡大で可愛くても、引きで読めないなら削る。背景は“情報の読みやすさ”が大事。',
        },
        {
          title: '小物は“役割”で選ぶ',
          body: '生活感、作業感、世界観…役割がある小物だけ残すと統一感が保てる。',
        },
        {
          title: '色数の制限が効く',
          body: '小物が増えるほど色が増えて崩れる。色数を縛ると自然に整理される。',
        },
      ],
    },
    {
      parent: {
        title: 'ハードサーフェスの角処理、正解が分からない',
        body: '丸めすぎるとおもちゃ、立てると嘘っぽい。どこで決める？',
      },
      replies: [
        {
          title: '素材で“丸さ”を変える',
          body: 'プラは少し丸い、金属は立つ、みたいに素材ルールを決めると迷いが減る。',
        },
        {
          title: '大きい角だけ丸めると安定',
          body: '全部に同じベベルを入れない。視線に入る角だけ丁寧にすると説得力が出る。',
        },
        {
          title: 'シルエット優先で判断する',
          body: '拡大で綺麗でも、引きで形が弱いと負ける。引きの輪郭で決めた方が早い。',
        },
      ],
    },
    {
      parent: {
        title: '短いループ映像、つなぎ目がどうしてもバレる',
        body: '最後と最初が同じでもバレる。何を揃えるべき？',
      },
      replies: [
        {
          title: '動きの方向と明るさがバレやすい',
          body: '位置を合わせても、光量の変化でバレる。変化量を揃えると自然になる。',
        },
        {
          title: '視線誘導を揃えると強い',
          body: '見る場所が移動すると“切り替わった感”が出る。注目点を固定するとループが見えにくい。',
        },
        {
          title: 'ループ前提の動きにする',
          body: '戻すより、最初から循環する動き（回転・波・呼吸）に寄せた方が綺麗。',
        },
      ],
    },
    {
      parent: {
        title: 'テクスチャ、ノイズを足してもリアルにならない',
        body: '石畳作ってるけど嘘っぽい。次に何を足せばいい？',
      },
      replies: [
        {
          title: '欠けやひびに“理由”を入れる',
          body: 'ランダムは嘘っぽい。割れ方に方向や力の流れを入れると一気にリアルになる。',
        },
        {
          title: 'サイズ感を揃えると落ち着く',
          body: '大きさがバラバラだと違和感が出やすい。まず形のルールを固めてからノイズ。',
        },
        {
          title: '影（凹凸）の出し方が命',
          body: '色より凹凸の読みが大事。ハイライトと影の幅を整えると説得力が増える。',
        },
      ],
    },
    {
      parent: {
        title: 'UIアイコン、細かいほど読めない問題',
        body: '小さいサイズだとディテールが消える。どう割り切るのがいい？',
      },
      replies: [
        {
          title: 'シルエットで意味を伝える',
          body: '細部じゃなく形で伝えるのが正解。線を減らすほど読みやすいことが多い。',
        },
        {
          title: '線幅と余白を先に決める',
          body: 'バラバラだと一気に素人感が出る。線幅・角丸・余白を固定すると揃う。',
        },
        {
          title: 'サイズ別に作り分けもアリ',
          body: '小サイズは簡略版、大サイズは詳細版、みたいに別物として作ると破綻しにくい。',
        },
      ],
    },

    // ---- ゲーム制作（6）----
    {
      parent: {
        title: '2Dアクション、移動が硬い',
        body: '加速/減速を入れたけどまだ硬い。触るべきポイントが分からない。',
      },
      replies: [
        {
          title: '入力→反応の遅れがあると硬い',
          body: '最初の一歩だけ反応を速くして、止まる時は少し粘る、みたいに非対称にすると気持ちよくなりやすい。',
        },
        {
          title: 'ジャンプの落下が気持ちよさに直結する',
          body: '上昇と落下の重さを変えると手触りが変わる。落下を少し強めると締まることが多い。',
        },
        {
          title: '効果音と揺れで“返事”を足すのも効く',
          body: '物理だけで解決しない時は、SE/カメラ/エフェクトで返事を足すと体感が上がる。',
        },
      ],
    },
    {
      parent: {
        title: 'パズルのルール説明、読まれない',
        body: '文章で説明すると飛ばされる。どうやって教えるのがいい？',
      },
      replies: [
        {
          title: '最初の2ステージを“教える専用”にする',
          body: '成功体験で理解させると説明がいらなくなる。文章は最小でいい。',
        },
        {
          title: '失敗理由を短く出すと学びやすい',
          body: '「何がダメだったか」が見えると、説明より早く理解してくれる。',
        },
        {
          title: 'UIの誘導で迷いを減らす',
          body: '押せる場所を強調したり、最初だけヒント表示したりすると“読む”が減る。',
        },
      ],
    },
    {
      parent: {
        title: 'ホラーの音、情報を出しすぎると怖くない？',
        body: '方向が分かる音を入れると楽になりすぎそう。でも分からないと理不尽。',
      },
      replies: [
        {
          title: '理不尽は怖さじゃなくストレス',
          body: '最低限の情報は出した方がいい。怖さは“見えない”で作って、迷子は作らない。',
        },
        {
          title: '音は“確信”じゃなく“予感”にする',
          body: '方向が断定できる音より、なんとなく気配がするくらいの方が怖さは残る。',
        },
        {
          title: '難易度で調整できるようにすると安心',
          body: 'イージーはヒント多め、ハードは少なめ、みたいに調整できると両立しやすい。',
        },
      ],
    },
    {
      parent: {
        title: 'ADVの既読スキップ、実装コストが高い',
        body: '既読だけスキップにしたいけど管理が面倒。どこまでやるべき？',
      },
      replies: [
        {
          title: '最初は粗め管理でも成り立つ',
          body: '章単位やシーン単位で既読扱いにしても体験は良くなる。完璧を目指すと沼る。',
        },
        {
          title: 'ログ機能があるだけで救われることが多い',
          body: 'スキップが弱くてもログが強いとストレスが減る。優先度を付けると楽。',
        },
        {
          title: 'ユーザーの目的次第',
          body: '周回前提なら既読スキップは重要。物語1回で終わるなら、オートと早送りだけでも許される。',
        },
      ],
    },
    {
      parent: {
        title: 'ドット絵の斜め移動、破綻する',
        body: '8方向にすると斜めが崩れる。割り切りの基準が欲しい。',
      },
      replies: [
        {
          title: '最初は4方向でも全然アリ',
          body: '完成させるのが最優先。8方向は後から追加でもいい。',
        },
        {
          title: '斜めは情報量を減らすと安定する',
          body: '横と同じ情報を詰めると破綻する。線を減らして形だけ残すと崩れにくい。',
        },
        {
          title: 'アニメ枚数を増やしすぎない',
          body: '枚数が多いほど粗が見えることもある。少ない枚数で気持ちよく見える形を探す方が早い。',
        },
      ],
    },
    {
      parent: {
        title: '説明なしチュートリアル、伝わってるか不安',
        body: '視線誘導で教えるのをやってみたけど、正しく伝わってるか自信がない。',
      },
      replies: [
        {
          title: '喋らずに人に触ってもらうのが一番',
          body: '詰まった場所＝改善点。見てるだけで答えが出る。',
        },
        {
          title: '失敗して学べる安全な場所を作る',
          body: '“ここで試せ”が分かると理解が速い。いきなり本番ギミックは難しい。',
        },
        {
          title: '誘導は1つずつ出す',
          body: '同時に色々教えると迷う。最初は1要素だけに絞ると伝わりやすい。',
        },
      ],
    },
  ]
}
